%versi 3 (22-07-2020)
\chapter{Landasan Teori}
\label{chap:teori}

\section{SharIF Judge}
\label{sec:sharifjudge} 
 
SharIF Judge \cite{SharIF_Judge} (dengan huruf kapital ``IF'') merupakan perangkat lunak berbasis web yang digunakan untuk menilai kode program dalam bahasa C, C++, Java, dan Python. SharIF Judge yang dibahas dalam dokumen ini adalah versi fork dari Sharif Judge \cite{Sharif_Judge_Original} (dengan huruf kecil ``if'') yang dibuat oleh Mohammad Javad Naderi. Versi fork ini dikembangkan sesuai dengan kebutuhan jurusan Teknik Informatika UNPAR dalam proses penilaian di beberapa mata kuliah. SharIF judge dibuat dengan PHP pada framework CodeIgniter dan BASH untuk backend.

\subsection{Fitur}
Berikut adalah fitur-fitur dari SharIF Judge.
\begin{enumerate}
	\item  Terdapat beberapa role pengguna, antara lain admin, head instructor, instructor, dan student.
	\item  Sandboxing (belum tersedia untuk Python)
	\item Deteksi kecurangan (mendeteksi kemiripan kode) menggunakan Moss
	\item Pengaturan untuk keterlambatan pengumpulan
	\item Antrian pengiriman
	\item Mengunduh hasil dalam bentuk file excel
	\item Mengunduh kode yang dikirim dalam bentuk file zip
	\item Metode``Output Comporison" dan``Tester Code'' untuk memeriksa kebenaran dari hasil output
	\item Menambahkan beberapa pengguna sekaligus
	\item Deskripsi masalah (PDF/Markdown/HTML)
	\item Penilaian ulang (rejudge)
	\item Papan Nilai (Scoreboard) dan Notifikasi (Notifications)
	
\end{enumerate}

\subsection{Instalasi}
Untuk menjalankan SharIF Judge, dibutuhkan sebuah server Linux dengan syarat sebagai berikut:
\begin{itemize}
	\item Webserver menjalankan PHP versi 5.3 atau lebih baru
	\item Pengguna dapat menjalankan PHP melalui command line.
	\item Menggunakan database MySql atau PostgreSql.
	\item PHP harus diberikan akses untuk untuk menjalankan perintah menggunakan fungsi shell exec (pakai underscore).
	\item Tools yang digunakan untuk melakukan kompilasi dan menjalankan kode yang dikumpulkan.
	\item Perl lebih baik diinstal untuk alasan ketepatan waktu, batas memori dan memaksimalkan batas ukuran pada output kode yang dikirim.
\end{itemize}



%\dtext{11-12} 

%\section{\LaTeX}
\section{PHP Standards Recommendations}
\label{sec:psr}

PHP Standards Recommendations (PSR) adalah kumpulan rekomendasi yang dibuat oleh PHP Framework Interop Group (PHP-FIG) untuk membantu para pengembang PHP dalam menciptakan kode yang lebih mudah dibaca, dipahami, dan dipelihara. 
Dalam PSR, terdapat kata kunci prioritas yang diatur dalam dokumen RFC 2119 \cite{RFC2119} dari PSR sendiri. Dikarenakan sumber referensi berbahasa Inggris, maka ada beberapa penyesuaian yang diperlukan untuk dokumen ini \footnote{Beberapa kata kunci memiliki tingkatan yang setara sehingga dikategorikan dan ditulis dalam satu poin. Misalnya, ``MUST'', ``REQUIRED'', dan ``SHALL'' berada dalam satu tingkatan yang setara sesuai deskripsi pada RFC 2119. Pemilihan kata ``HARUS'', ``DILARANG'', dan sebagainya digunakan untuk penyesuaian dalam bahasa Indonesia agar struktur kalimat tidak rancu.}.

\begin{itemize}
	\item ``MUST'', ``REQUIRED'', ``SHALL'' akan ditulis sebagai ``HARUS'' dengan arti harus sesuai.
	\item ``MUST NOT'', ``SHALL NOT'' akan ditulis sebagai ``DILARANG'' atau ``TIDAK'' dengan arti dilarang atau tidak diperbolehkan.
	\item ``SHOULD'', ``RECOMMENDED'' akan ditulis sebagai ``SEBAIKNYA'' atau ``DIREKOMENDASIKAN'' dengan arti direkomendasikan untuk digunakan namun tetap memperhatikan keadaan dan kebutuhan.
	\item ``SHOULD NOT'', ``NOT RECOMMENDED'' akan ditulis sebagai ``SEBAIKNYA TIDAK'' atau ``TIDAK DIREKOMENDASIKAN'' dengan arti tidak direkomendasikan untuk digunakan namun tetap memperhatikan keadaan dan kebutuhan.
	\item ``MAY'', ``OPTIONAL'' akan ditulis ``BOLEH'' atau ``BISA'' dengan arti bersifat tidak wajib.
\end{itemize}


Setiap PSR memiliki status, antara lain ``Accepted'', ``Draft'', ``Abandoned'', dan ``Deprecated''. Aturan-aturan PSR yang digunakan hanyalah yang berstatus ``Accepted''. Saat dokumen ini dibuat, terdapat 23 bab PSR dengan rincian sebagai berikut.
\begin{comment}
\begin{enumerate}
	\item{Accepted}
	\begin{itemize}
		\item PSR-01: Basic Coding Standard
		\item PSR-03: Logger Interface
		\item PSR-04: Autoloading Standard
		\item PSR-06: Caching Interface
		\item PSR-07: HTTP Message Interface
		\item PSR-11: Container Interface
		\item PSR-12: Extended Coding Style Guide
		\item PSR-13: Hypermedia Links
		\item PSR-14: Event Dispatcher
		\item PSR-15: HTTP Handlers
		\item PSR-16: Simple Cache
		\item PSR-17: HTTP Factories
		\item PSR-18: HTTP Client
		\item PSR-20: Clock
	\end{itemize}

	\item{Draft}
	\begin{itemize}
		\item PSR-05: PHPDoc Standard
		\item PSR-19: PHPDoc Tags
		\item PSR-21: Internationalization
		\item PSR-22: Application Tracing
	\end{itemize}
	
	\item{Abandoned}
	\begin{itemize}
		\item PSR-08: Huggable Interface
		\item PSR-09: Security Advisories
		\item PSR-10: Security Reporting Process
	\end{itemize}
	
	\item{Deprecated}
	\begin{itemize}
		\item PSR-00: Autoloading Standard
		\item PSR-02: Coding Style Guide
	\end{itemize}
	
	
\end{enumerate}
\end{comment}

\subsection{Accepted}
\label{subsec:accepted}
Status ``Accepted'' adalah bab-bab aturan yang sudah diterima, disepakati, dan diawasi oleh tim kerja bersangkutan untuk digunakan oleh para pengembang. Untuk mempermudah sitasi dalam proses evaluasi, setiap aturan PSR ditandai dengan kode PSR-XXYY, di mana XX menunjukkan bab PSR dan YY menunjukkan urutan aturan dalam bab tersebut.

\subsubsection{PSR-01: Basic Coding Standard}
\label{subsubsec:psr01}
\begin{itemize}
	\item \textit{File} (PSR-0101) HARUS menggunakan \textit{tag} \verb|<?php|  dan \verb|<?=| dan (PSR-0102)TIDAK menggunakan variasi \textit{tag} lainnya.
	\item \textit{File} (PSR-0103) HARUS menggunakan UTF-8 tanpa Byte Order Mark (BOM) untuk kode PHP.
	\item \textit{File} (PSR-0104) SEBAIKNYA mendeklarasikan simbol (kelas, fungsi, konstanta, dan lain-lain) atau menyebabkan efek samping (misalnya menghasilkan output, mengubah pengaturan .ini, dan lain-lain), tetapi (PSR-0105) SEBAIKNYA TIDAK keduanya.
	\item \textit{Namespace} dan kelas (PSR-0106) HARUS mengikuti PSR ``autoloading'': [PSR-4].
	\item Nama kelas (PSR-0107) HARUS dideklarasikan di \verb|StudlyCaps|.
	\item Kode yang ditulis untuk PHP 5.3 dan setelahnya (PSR-0108) HARUS menggunakan \textit{namespace} formal.
	\item Kode yang ditulis untuk PHP 5.2.x dan sebelumnya (PSR-0109) SEBAIKNYA menggunakan konvensi \textit{pseudo-namepsacing} dengan awalan  \verb|Vendor_|  pada nama kelas.
	\item Konstanta kelas (PSR-0110) HARUS dideklarasikan dalam huruf kapital dengan pemisah garis bawah.
	\item Konvensi penamaan apa pun (PSR-0111) SEBAIKNYA diterapkan secara konsisten dalam lingkup yang masuk akal, baik itu tingkat \textit{vendor}, tingkat \textit{package}, tingkat \textit{class}, atau tingkat \textit{method}.
	\item Nama \textit{method} (PSR-0112) HARUS dideklarasikan dalam \verb|camelCase|.
\end{itemize}

\subsubsection{PSR-03: Logger Interface}
\label{subsubsec:psr03}
\begin{itemize}
	\item \verb|Logger Interface| memiliki delapan \textit{method} untuk menulis log ke delapan level RFC 5424 (debug, info, notice, warning, error, critical, alert, emergency). Terdapat satu \textit{method} lainnya, \verb|log|, menerima level log sebagai argumen pertama. Memanggil \textit{method} ini dengan salah satu konstanta level log (PSR-0301) HARUS memiliki hasil yang sama dengan memanggil \textit{method} pada level yang spesifik. Memanggil \textit{method} ini dengan level yang tidak ada pada spesifikasi ini (PSR-0302) HARUS melempar \verb|Psr\Log\InvalidArgumentException| jika implementasinya tidak tahu tentang level tersebut. Pengguna (PSR-0303) SEBAIKNYA JANGAN menggunakan level versi berbeda tanpa tahu dengan pasti jika implementasi yang sekarang mendukung. 
	\item Setiap \textit{method} menerima string sebagai pesan, atau objek dengan \textit{method} \verb|__toString()|. \textit{Implementor} (PSR-0304) BISA memiliki \textit{handling} khusus untuk objek yang diteruskan. Jika bukan demikian, maka \textit{implementor} harus mengubahnya ke sebuah string.
	\item Pesan (PSR-0305) BISA memiliki \textit{placeholder} yang (PSR-0306) BISA diganti oleh \textit{implementor} dari \textit{context array}.
	\item Nama \textit{placeholder} harus sesuai dengan kunci dalam \textit{context array}.
	\item Nama placeholder (PSR-0307) HARUS dipisahkan dengan kurung kurawal buka tunggal \verb|{| dan kurung kurawal tutup tunggal \verb|}|. (PSR-0308) TIDAK BOLEH ada spasi kosong antara pembatas dan nama \textit{placeholder}.
	\item Nama \textit{placeholder} (PSR-0309) SEBAIKNYA hanya terdiri dari karakter \verb|A-Z|, \verb|a-z|, \verb|0-9|, garis bawah \verb|_|, dan titik \verb|.|.
	\item \textit{Implementor} (PSR-0310) BISA menggunakan \textit{placeholder} untuk menerapkan berbagai strategi \textit{escaping} dan menerjemahkan log untuk ditampilkan. Pengguna (PSR-0311) SEBAIKNYA TIDAK melakukan \textit{pre-escape} nilai dalam \textit{placeholder} karena mereka tidak tahu dalam konteks mana data akan ditampilkan. 
	\item Setiap \textit{method} menerima array sebagai data konteks. Ini dimaksudkan untuk menyimpan informasi asing yang tidak sesuai dengan string. Array dapat berisi apa saja. \textit{Implementor} (PSR-0312) HARUS memastikan mereka memperlakukan data konteks dengan kelonggaran sebanyak mungkin. Nilai yang diberikan dalam konteks (PSR-0313) TIDAK BOLEH melempar \textit{exception} atau menimbulkan \textit{error}, peringatan, atau pemberitahuan PHP apa pun.
	\item Jika objek \verb|Exception| diteruskan dalam data konteks, maka (PSR-0314) HARUS berada dalam \textit{key} \verb|`exception'|. \textit{Implementor} (PSR-0315) HARUS tetap memastikan bahwa\textit{key} \verb|`exception'| adalah sebuah objek \verb|Exception|, karena isinya (PSR-0316) BISA mengandung apa saja.
\end{itemize}

\subsubsection{PSR-04: Autoloading Standard}
\label{subsubsec:psr04}
\begin{itemize}
	\item Istilah ``kelas'' mengacu pada kelas, \textit{interface}, \textit{traits}, dan struktur lain yang serupa.
	\item Nama kelas yang memenuhi syarat memiliki bentuk \verb|\<NamespaceName>(\<SubNamespaceNames>)*\<ClassName>| dengan spesifikasi berikut:
	\begin{enumerate}
		\item (PSR-0401) HARUS memiliki nama \textit{namespace} tingkat tertinggi, atau dikenal sebagai ``vendor namespace''.
		\item (PSR-0402) BISA memiliki satu atau lebih nama \textit{sub-space}.
		\item (PSR-0403) HARUS memiliki nama kelas di akhir.
		\item Garis bawah tidak memiliki makna khusus.
		\item Karakter abjad (PSR-0404) BISA berisi kombinasi dari huruf kapital dan huruf kecil.
		\item Semua nama kelas harus direferensikan dengan cara yang \textit{case-sensitive}.
	\end{enumerate}
	\item Implementasi \textit{autoloader} (PSR-0405) TIDAK BOLEH melempar \textit{exception}, (PSR-0406) TIDAK BOLEH memunculkan \textit{error} dalam tingkat apa pun, dan (PSR-0407) SEBAIKNYA TIDAK mengembalikan nilai. 
\end{itemize}

\subsubsection{PSR-06: Caching Interface}
\label{subsubsec:psr06}
\begin{itemize}
	\item \textit{Library} pelaksana (PSR-0601) HARUS menyediakan kelas yang mengimplementasikan \textit{interface} \verb|Cache\CacheItemPoolInterface| dan \verb|Cache\CacheItemInterface|. Impementasinya (PSR-0602) HARUS mendukung fungsionalitas TTL minimum dengan perincian detik yang penuh. Time To Live (TTL) suatu item adalah jumlah waktu antara waktu saat item tersebut disimpan dan ketika item dianggap kedaluwarsa. TTL biasanya didefinisikan dalam bentuk bilangan bulat (integer) yang mewakili waktu dalam detik, atau sebuah objek DateInterval.
	\item \textit{Libarary} pelaksana (PSR-0603) BISA mengakhiri masa berlaku item sebelum \textit{Expiration Time} yang diminta, tetapi (PSR-0604) HARUS mengakhiri masa berlaku item tersebut jika \textit{Expiration Time} sudah tercapai. Jika suatu \textit{libary} meminta item untuk disimpan tanpa menentukan waktu kedaluwarsa, atau ditentukan isinya null atau TTL,  \textit{library} pelaksana (PSR-0605) BISA menggunakan durasi default yang sudah dikonfigurasi. Jika belum ada durasi defaut yang dikonfigurasi, maka \textit{library} pelaksana (PSR-0606) HARUS menafsirkannya sebagai permintaan untuk menyimpan item dalam cache selamanya, atau selama implementasi yang mendasarinya mendukung.
	\item \textit{Key} adalah suatu string yang terdiri dari minimal satu karakter yang secara unik mengidentifikasi item yang di-\textit{cache}. \textit{Library} pelaksana (PSR-0607) HARUS mendukung \textit{key} yang terdiri dari karakter \verb|A-Z|, \verb|a-z|, \verb|0-9|, \verb|_|, dan \verb|.| dengan urutan apa pun dalam pengkodean UTF-8 dan maksimum 64 karakter. \textit{Library} pelaksana (PSR-0608) BISA mendukung karakter tambahan dan pengkodean atau karakter yang lebih banyak, namun harus memenuhi syarat minimum di atas.
	\item Dalam mengimplementasikan \textit{library} semuanya (PSR-0609) HARUS mendukung semua tipe data PHP bersambung, termasuk: 
	\begin{itemize}
		\item String
		\item Integer
		\item Float
		\item Boolean
		\item Null
		\item Array
		\item Object - Setiap Object (PSR-0610) BISA memanfaatkan antarmuka Serializable PHP, metode \verb|__sleep()| atau \verb|__wakeup()|, atau fungsi serupa lain jika diperlukan.
	\end{itemize}
	\item Semua data yang diteruskan ke \textit{library} Pelaksana (PSR-0611) HARUS dikembalikan sama persis seperti data yang diteruskan tersebut.
	\item \textit{Library} Pelaksana (PSR-0612) BISA menggunakan fungsi PHP \verb|serialize()|/\verb|unserialize()| secara internal tetapi tidak diwajibkan.
	\item Jika tidak dimungkinkan untuk mengembalikan \textit{value} yang tersimpan sama persis untuk alasan apa pun, \textit{library} pelaksana harus memberikan respons dengan kehilangan \textit{cache}, bukan data yang rusak (\textit{corrupted}).
	\item Pool merepresentasikan kumpulan \textit{item} dalam sistem \textit{caching}. Pool adalah repositori logis dari \textit{item}-\textit{item} di dalamnya. Semua \textit{item} yang dapat di-\textit{cache} diambil dari Pool sebagai objek Item, dan semua interaksi yang terjadi antar objek yang di-\textit{cache} terjadi melalui Pool.
	Item merepresentasikan satu pasangan \textit{key}/\textit{value} dalam suatu Pool. \textit{Key} adalah penanda unik untuk suatu \textit{item} dan (PSR-0613) HARUS \textit{immutable} (tidak dapat diubah). \textit{Value} BISA diubah setiap waktu.
	\item Meskipun \textit{caching} sering kali merupakan bagian penting dari kinerja aplikasi, \textit{caching} tidak boleh memengaruhi fungsionalitas aplikasi. Oleh karena itu, kesalahan dalam sistem \textit{cache} (PSR-0614) TIDAK BOLEH mengakibatkan kegagalan aplikasi. Untuk alasan tersebut, \textit{Library}  Pelaksana (PSR-0615) TIDAK BOLEH melempar \textit{exception} selain yang ditentukan oleh antarmuka, dan (PSR-0616) HARUS menangkap \textit{error} atau \textit{exception} apa pun yang dipicu oleh penyimpanan data yang mendasarinya (dan tidak membiarkannya menggelembung).
	\item \textit{Library} Pelaksana (PSR-0617) HARUS mencatat \textit{error} tersebut atau melaporkannya ke administrator sebagaimana mestinya.
	\item Jika \textit{Library} Pemanggil meminta agar satu atau lebih Item dihapus, atau pool dibersihkan, maka (PSR-0618) TIDAK BOLEH dianggap sebagai kondisi \textit{error} jika \textit{key} yang ditentukan tidak ada. Kondisi pasca pun sama (\textit{key} tidak ada, atau pool kosong), sehingga tidak ada kondisi error.
\end{itemize}

\subsubsection{PSR-07: HTTP Message Interface}
\label{subsubsec:psr07}
Standar PSR-07 tidak ditulis pada dokumen ini sebagaimana telah dicantumkan pada Batasan Masalah di Bab 1 Pendahuluan.
\begin{comment}
\begin{itemize}
	\item Pesan HTTP dapat berupa permintaan dari klien ke server atau respons dari server ke klien.
	\item MUST
	\item SHOULD
	\item Selama konstruksi, implementasi HARUS berusaha menyetel header  \verb|Host| dari URI yang disediakan jika tidak ada header \verb|Host| yang tersedia.
	\item Klien HTTP HARUS mengabaikan nilai dari \verb|Uri::getPath()| dan \verb|Uri::getQuery()|, sebaliknya menggunakan nilai yang dikembalikan oleh \verb|getRequestTarget()|, yang secara default menggabungkan kedua nilai ini.
	\item Klien yang memilih untuk tidak mengimplementasi 1 atau lebih dari 4 formulir \textit{request-target}, HARUS tetap menggunakan \verb|RequestTarget()|. Klien-klien ini HARUS menolak \textit{request-target} yang tidak mereka dukung, dan DILARANG kembali ke nilai dari \verb|getUri()|.
\end{itemize}
\end{comment}

\subsubsection{PSR-11: Container Interface}
\label{subsubsec:psr11}
\begin{itemize}
	\item \textit{Entry identifier} adalah string legal PHP apa pun yang setidaknya terdiri dari satu karakter unik yang mengidentifikasi sebuah item dalam suatu \textit{container}. \textit{Entry identifier} adalah sebuah string buram, maka pemanggil (PSR-1101) SEBAIKNYA TIDAK berasumsi bahwa struktur string memiliki makna semantik apa pun.
	\item Dalam \verb|Psr\Container\ContainerInterface| terdapat 2 metode: \verb|get| dan \verb|has|.
	\item Pengecualian yang diberikan secara langsung oleh \textit{container} (PSR-1102) SEBAIKNYA mengimplementasi \verb|Psr\Container\ContainerExceptionInterface|.
	\item Panggilan ke metode \verb|get| dengan id yang tidak ada (PSR-1103) HARUS memunculkan \verb|Psr\Container\NotFoundExceptionInterface|.
	\item Pengguna (PSR-1104) SEBAIKNYA TIDAK meneruskan suatu \textit{container} ke objek sehingga objek dapat mengambil sendiri dependensinya. Hal ini berarti \textit{container} digunakan sebagai \textit{Service Locator} yang merupakan pola yang umumnya tidak dianjurkan.
\end{itemize}

\subsubsection{PSR-12: Extended Coding Style Guide}
\label{subsubsec:psr12}
Standar PSR-12 tidak ditulis pada dokumen ini sebagaimana telah dicantumkan pada Batasan Masalah di Bab 1 Pendahuluan.


\subsubsection{PSR-13: Hypermedia Links}
\label{subsubsec:psr13}
\textit{Link} Hypermedia paling sedikit terdiri dari:
\begin{enumerate}
	\item URI yang merepresentasikan \textit{resource} target yang direferensikan.
	\item Suatu hubungan yang mendefinisikan bagaimana \textit{resource} target berhubungan dengan asal sumbernya.
\end{enumerate}

Berbagai atribut \textit{Link} lainnya mungkin ada, tergantung pada format yang digunakan. Dikarenakan atribut tambahan tidak terstandarisasi dengan baik atau bersifat universal, spesifikasi ini tidak berupaya untuk membuatnya standar.

Untuk keperluan spesifikasi ini, definisi berikut berlaku.
\begin{enumerate}
	\item Implementing Object - Objek yang mengimplementasikan salah satu antarmuka yang ditentukan oleh spesifikasi ini.
	\item Serializer - Sebuah \textit{library} atau sistem lain yang mengambil satu atau lebih objek Link dan membuat representasi serial dalam beberapa format yang ditentukan.
\end{enumerate}

\begin{itemize}
	\item Semua tautan (PSR-1301) BOLEH menyertakan nol atau lebih atribut tambahan di luar URI dan hubungannya.
	\item Serializer (PSR-1302) BOLEH menghilangkan atribut pada objek \textit{link} jika diperlukan oleh format serialisasi. Namun, serializer (PSR-1303) HARUS menyandikan (\textit{encode}) semua atribut yang disediakan untuk memungkinkan ekstensi pengguna kecuali dicegah oleh definisi format serialisasi.
\end{itemize}


\subsubsection{PSR-14: Event Dispatcher}
\label{subsubsec:psr14}
\begin{itemize}
	\item Sebuah \textit{Listener} (PSR-1401) BISA melakukan beberapa \textit{behavior} asinkron jika diinginkan.
	\item Sebuah \textit{Dispatcher} bertanggung jawab untuk memastikan bahwa \textit{Event} diteruskan ke semua \textit{Listener} yang relevan, tetapi (PSR-1402) HARUS menunggu sesuai \textit{listener} yang bertanggung jawab ke \textit{Listener Provider}.
	\item Sebuah \textit{Listener Provider} bertanggung jawab untuk menentukan \textit{Listener} apa yang relevan sesuai \textit{Event} tertentu, tetapi (PSR-1403) TIDAK BOLEH memanggil \textit{Listener} itu sendiri.
	\item Objek \textit{Event} BISA berubah jika kasus penggunaannya memanggil \textit{Listener} yang memberikan informasi ke \textit{Emitter}.
	\item Jika tidak ada komunikasi dua arah yang diperlukan, maka (PSR-1404) DIREKOMENDASIKAN agar \textit{Event} ditetapkan sebagai \textit{mutable}; yaitu didefinisikan sedemikian rupa sehingga tidak memiliki \textit{method} mutator.
	\item Pengimplementasi (PSR-1405) HARUS berasumsi bahwa objek yang sama akan diteruskan ke semua \textit{Listener}.
	\item (PSR-1406) DIREKOMENDASIKAN tetapi (PSR-1407) TIDAK DIHARUSKAN bahwa objek \textit{Event} mendukung serialisasi dan deserialisasi \textit{lossless}; \verb|$event == unserialize(serialize($event))| (PSR-1408) SEBAIKNYA bernilai  \textit{true}.
	\item Objek (PSR-1409) BISA memanfaatkan \textit{interface} PHP \verb|Serializable|, \verb|__sleep()| atau \verb|__wakeup()| \textit{magic method}, atau fungsionalitas bahasa yang serupa jika dibutuhkan.
	\item Sebuah \textit{Event} yang mengimplementasikan \verb|StoppableEventInterface| (PSR-1410) HARUS mengembalikan \verb|true| dari \verb|isPropagationStopped()| ketika \textit{Event} apa pun yang direpresentasikannya telah selesai.
	\item Sebuah \textit{Listener} (PSR-1411) HARUS memiliki satu dan hanya satu parameter, yaitu \textit{Event} yang diresponsnya.
	\item \textit{Listener} (PSR-1412) SEBAIKNYA menuliskan petunjuk bahwa parameter secara spesifik relevan untuk kasus penggunaannya; yaitu \textit{Listener} (PSR-1413) BISA menuliskan petunjuk terhadap sebuah \textit{interface} untuk menunjukkan bahwa \textit{interface} tersebut kompatibel dengan semua jenis \textit{Event} yang mengimplementasikannya, atau dengan implementasi khusus dari antarmuka tersebut.
\end{itemize}

\subsubsection{PSR-15: HTTP Handlers}
\label{subsubsec:psr15}
\begin{itemize}
	\item \textit{Request handler} (PSR-1501) BOLEH memberi pengecualian jika kondisi permintaan mencegahnya untuk membuat respons. Jenis pengecualiannya tidak ditentukan.
	\item Setiap \textit{request handler} yang menggunakan standar ini (PSR-1502) HARUS mengimplementasikan \textit{interface} \verb|Psr\Http\Server\RequestHandlerInterface|.
	\item Komponen \textit{middleware} (PSR-1503) BOLEH membuat dan mengembalikan respons tanpa mendelegasikan ke \textit{request handler}, jika kondisi yang dibutuhkan sudah terpenuhi.
	\item \textit{Middleware} yang menggunakan standar ini (PSR-1504) HARUS mengimplementasikan \textit{interface} \verb|Psr\Http\Server\MiddlewareInterface|.
	\item Setiap \textit{middleware} atau \textit{request handler} yang menghasilkan respons (PSR-1505) DIREKOMENDASIKAN untuk membuat prototipe PSR-07 \verb|ResponseInterface| atau pabrik yang mampu menghasilkan \textit{instance} \verb|ResponseInterface| untuk mencegah ketergantungan pada implementasi pesan HTTP tertentu.
	\item Setiap aplikasi yang menggunakan \textit{middleware} (PSR-1506) DIREKOMENDASIKAN untuk menyertakan komponen yang menangkap pengecualian dan mengubahnya menjadi respons. \textit{Middleware} ini (PSR-1507) HARUS menjadi komponen pertama yang dieksekusi dan mencakup semua pemrosesan lebih lanjut untuk memasukan bahwa respons selalu dibuat. 
	\item Sebuah \textit{Listener} (PSR-1508) SEBAIKNYA memiliki kembalian \verb|void|, dan (PSR-1509) SEBAIKNYA menuliskan petunjuk yang mengembalikan secara eksplisit. Sebuah \textit{Dispatcher} (PSR-1510) HARUS mengabaikan nilai kembalian dari \textit{Listener}.
	\item Sebuah \textit{Listener} (PSR-1511) BISA mendelegasikan tindakan ke kode lain. Hal ini termasuk \textit{Listener} yang menjadi pembungkus sebuah objek yang menjalankan \textit{business logic} yang sebenarnya.
	\item Sebuah Listener (PSR-1512) BISA menyusun informasi dari \textit{Event} untuk diproses nanti oleh proses sekunder, menggunakan cron, sebuah server antrean, atau dengan teknik serupa. Hal ini (PSR-1513) BISA membuat serial objek \textit{Event} itu sendiri untuk melakukannya; namun harus berhati-hati agar tidak semua objek \textit{Event} dapat diserialkan dengan aman. Sebuah proses sekunder (PSR-1514) HARUS berasumsi bahwa setiap perubahan yang dibuatnya ke suatu objek \textit{Event} tidak akan menyebar ke \textit{Listener} lain. 
\end{itemize}

\subsubsection{PSR-16: Simple Cache}
\label{subsubsec:psr16}
\begin{itemize}
	\item \textit{Library} pelaksana HARUS menyediakan kelas yang mengimplementasikan antarmuka \verb|Psr\SimpleCache\CacheInterface interface|. \textit{Library} pelaksana HARUS mendukung fungsionalitas TTL minimum seperti yang disebutkan pada PSR-06.
	
\end{itemize}

\subsubsection{PSR-17: HTTP Factories}
\label{subsubsec:psr17}
\begin{itemize}
	\item HTTP \textit{factory} adalah metode yang digunakan untuk membuat objek HTTP baru sesuai yang didefinisikan oleh PSR-07. Setiap HTTP \textit{factory} (PSR-1701) HARUS mengimplementasi semua \textit{interface} berikut untuk setiap tipe objek yang disediakan oleh \textit{package}. \textit{Interface} berikut ini (PSR-1701) BOLEH diimplementasikan bersama dalam satu kelas atau kelas terpisah.
	\begin{enumerate}
		\item RequestFactoryInterface
		\item ResponseFactoryInterface
		\item ServerRequestFactoryInterface
		\item StreamFactoryInterface
		\item UploadFileFactoryInterface
		\item UriFactoryInterface
	\end{enumerate} 
\end{itemize}

\subsubsection{PSR-18: HTTP Client}
\label{subsubsec:psr18}
\begin{itemize}
	\item Klien (PSR-1801) BOLEH mengirim permintaan HTTP yang diubah dari yang disediakan, misalnya melakukan \textit{compress} pada badan pesan yang dikirim.
	\item Klien (PSR-1802) BOLEH memilih untuk mengubah respons HTTP yang diterima sebelum mengembalikannya ke \textit{library} pemanggil, misalnya melakukan \textit{decompress} isi pesan yang masuk. 
	\item Jika klien memilih untuk mengubah permintaan HTTP atau respons HTTP, klien (PSR-1803) HARUS memastikan bahwa objek tetap konsisten secara internal. Misalnya, jika klien memilih untuk dekompresi isi pesan, maka klien juga (PSR-1804) HARUS menghapus header \verb|Content-Encoding| dan menyesuaikan header \verb|Content-Length|.
	
	\item Klien (PSR-1805) HARUS menyusun kembali respons HTTP 1xx multi-langkah secara mandiri sehingga apa yang dikembalikan ke \textit{library} pemanggil adalah respons HTTP yang valid dengan kode status 200 atau di atasnya.
	
	\item Klien (PSR-1806) TIDAK BOLEH memperlakukan permintaan atau respons HTTP yang dibuat dengan baik sebagai kondisi \textit{error}. Sebagai contoh, kode status respons dalam rentang 400 dan 500 (PSR-1807) TIDAK BOLEH menimbulkan pengecualian dan (PSR-1808) HARUS dikembalikan ke \textit{library} pemanggil seperti biasa.
	\item Klien (PSR-1809) HARUS memberikan \textit{instance} \verb|Psr\Http\Client\ClientExceptionInterface| jika dan hanya jika tidak dapat mengirim permintaan HTTP sama sekali atau jika respons HTTP tidak dapat diuraikan menjadi objek respons PSR-07.
	\item Jika permintaan tidak dapat dikirim karena pesan permintaan bukan permintaan HTTP yang dibuat dengan baik atau kehilangan beberapa informasi penting (seperti Host atau Method), klien (PSR-1810) HARUS memberikan \textit{instance} \verb|Psr\Http\Client\RequestExceptionInterface|.
	\item Jika permintaan tidak dapat dikirim karena kegagalan jaringan dalam bentuk apa pun, termasuk \textit{timeout}, klien (PSR-1811) HARUS memberi instance \verb|Psr\Http\Client\NetworkExceptionInterface|.
	\item Klien (PSR-1812) MUNGKIN memberikan pengecualian yang lebih spesifik daripada yang ditentukan di sini (misalnya \verb|TimeOutException| atau \verb|HostNotFoundException|), asalkan mereka mengimplementasikan antarmuka yang sesuai yang ditentukan di atas.
\end{itemize}

\subsubsection{PSR-20: Clock}
\label{subsubsec:psr20}
\begin{itemize}
	\item Kembalian waktu (PSR-2001) HARUS ditulis sebagai \verb|\DateTimeImmutable|    
\end{itemize}

\subsection{Draft}
\label{subsec:draft}
Status ''Draft'' adalah bab-bab yang masih dalam tahap diskusi dan pengembangan lebih lanjut agar isinya layak untuk menjadi standar.

\subsubsection{PSR-05: PHPDoc Standard}
\label{subsubsec:psr05}

\subsubsection{PSR-19: PHPDoc tags}
\label{subsubsec:psr19}

\subsubsection{PSR-21: Internationalization}
\label{subsubsec:psr21}

\subsubsection{PSR-22: Application Tracing}
\label{subsubsec:psr22}


\subsection{Abandoned}
\label{subsec:abandoned}
Status ''Abandoned'' adalah bab-bab yang tidak lagi dikerjakan ataupun dikembangkan. oleh tim kerja yang bersangkutan. 

\subsubsection{PSR-08: Huggable Interface}
\label{subsubsec:psr08}

\subsubsection{PSR-09: Security Advisories}
\label{subsubsec:psr09}

\subsubsection{PSR-10: Security Reporting Process}
\label{subsubsec:psr10}


\subsection{Deprecated}
\label{subsec:deprecated}
Status ''Deprecated'' adalah bab-bab yang sudah pernah disetujui sebelumnya, namun dianggap sudah tidak relevan karena perubahan-perubahan seiring berjalannya waktu. Bab-bab ini tidak direkomendasikan untuk digunakan. Salah satu alasan lain adalah karena adanya bab baru yang lebih baik untuk menggantikannya.

\subsubsection{PSR-00: Autoloading Standard}
\label{subsubsec:psr00}

\subsubsection{PSR-02: Coding Style Guide}
\label{subsubsec:psr02}

%\dtext{13-14}


\section{PHP Coding Standards Fixer}
\label{sec:phplinter}
 
 \begin{comment}
 	content...Lint awalnya merujuk pada tool yang digunakan untuk menganalisis suatu kode program dengan tujuan menemukan kesalahan pada bahasa C. Kemudian istilah ini menjadi sebutan untuk mendeskripsikan hal-hal yang berkaitan dengan pengecekan kode program. PHP linter adalah tool yang digunakan untuk menganalisis kode PHP sesuai dengan standar tertentu. 
 	PHP linter yang digunakan adalah yang dibuat oleh Brueggern. Linter ini berdasar pada standar PSR ke-2 dan ke-12, yaitu Coding Style Guide yang sudah usang (deprecated) dan Extended Coding Style Guide sebagai penggantinya (accepted). 
 	
 	\subsection{Syarat Instalasi}
 	Sebelum menginstal linter, perlu dilakukan penginstalan Composer terlebih dahulu. Composer adalah alat untuk mengelola dependency pada PHP. 
 	
 	\subsection{Instalasi}
 	Berikut adalah langkah instalasi PHP linter.
 	\begin{enumerate}
 		\item Pada bagian root project, buka file composer.json.
 		\item Pada bagian "Repositories", tambahkan kode berikut.
 		\begin{lstlisting}[language=php, caption=kode kode, label=kode:aneh]
 			{
 				"repositories": [
 				{
 					"type": "vcs",
 					"url": "git@github.com:brueggern/php-linter.git"
 				}
 				]
 			}
 			
 		\end{lstlisting}
 		
 		\item Install composer package.
 		\verb|composer require brueggern/php-linter|  
 		
 		\item Tambahkan script berikut untuk menjalankan linting/fixing. "app" dapat diganti dengan nama file atau folder yang akan di-lint. 
 		\begin{lstlisting}[language=php, caption=kode kode, label=kode:aneh]
 			{
 				"scripts": {
 					"lint": "php-linter app",
 					"lint:fix": "php-linter --fix app"
 				}
 			}
 			
 		\end{lstlisting}
 	\end{enumerate}
 \end{comment}

PHP Coding Standards Fixer (PHP CS Fixer) \cite{PHP_CS_Fixer} adalah sebuah \textit{tool} yang dapat memperbaiki kode program agar mengikuti standar tertentu, misalnya standar dari PSR-1, PSR-2, dan lainnya, atau standar berbasis komunitas lain seperti Symfony.


\subsection{Penggunaan}
Untuk menjalankan linter perintah yang digunakan adalah:
	\verb|composer run lint|    

Untuk memperbaiki error secara otomatis, perintah yang digunakan adalah:

	\verb|composer run lint:fix|    

\begin{comment}
\subsection{Tabel}  
Berikut adalah contoh pembuatan tabel. 
Penempatan tabel dan gambar secara umum diatur secara otomatis oleh \LaTeX{}, perhatikan contoh di file bab2.tex untuk melihat bagaimana cara memaksa tabel ditempatkan sesuai keinginan kita.

Perhatikan bawa berbeda dengan penempatan judul gambar gambar, keterangan tabel harus diletakkan di atas tabel!!
Lihat Tabel~\ref{tab:contoh1} berikut ini:

\begin{table}[H] %atau h saja untuk "kira kira di sini"
	\centering 
	\caption{Tabel contoh}
	\label{tab:contoh1}
	\begin{tabular}{cccc}
		\toprule
		& $v_{start}$ & $\mathcal{S}_{1}$ & $v_{end}$\\

		\midrule
		$\tau_{1}$ & 1 & 12& 20\\
		$\tau_{2}$ & 1 &  & 20\\
		$\tau_{3}$ & 1 & 9 & 20\\
		$\tau_{4}$ & 1 &  & 20\\

		\bottomrule
		
	\end{tabular} 
\end{table}
Tabel~\ref{tab:cthwarna1} dan Tabel~\ref{tab:cthwarna2} berikut ini adalah tabel dengan sel yang berwarna dan ada dua tabel yang bersebelahan. 
\begin{table}[H]
	\begin{minipage}[c]{0.49\linewidth}
		\centering
		\caption{Tabel bewarna(1)}
		\label{tab:cthwarna1}
		\begin{tabular}{ccccc}
			\toprule
			 & $v_{start}$ & $\mathcal{S}_{2}$ & $\mathcal{S}_{1}$ & $v_{end}$\\
			
			\midrule
			$\tau_{1}$ & 1 & 5 \cellcolor{green}& 12& 20\\
			$\tau_{2}$ & 1 & 8 \cellcolor{green}& & 20\\
			$\tau_{3}$ & 1 & 2/8/17 \cellcolor{green}& 9 & 20\\
			$\tau_{4}$ & 1 & \cellcolor{red}& & 20\\
			
			\bottomrule

		\end{tabular}
	\end{minipage}
	\begin{minipage}[c]{0.49\linewidth}
		
		\centering 
		\caption{Tabel bewarna(2)}
		\label{tab:cthwarna2}
		\begin{tabular}{ccccc}
			\toprule
			 & $v_{start}$ & $\mathcal{S}_{1}$ & $\mathcal{S}_{2}$ & $v_{end}$\\
			
			\midrule
			$\tau_{1}$ & 1 & 12& 5 \cellcolor{red} &20\\
			$\tau_{2}$ & 1 &  &  8 \cellcolor{green} &20\\
			$\tau_{3}$ & 1 & 9 & 2/8/17 \cellcolor{green} &20\\
			$\tau_{4}$ & 1 &   & \cellcolor{red} &20\\
			
			\bottomrule
		
		\end{tabular}
	\end{minipage}
\end{table}

 
\subsection{Kutipan}
\label{subs:kutipan} 
Berikut contoh kutipan dari berbagai sumber, untuk keterangan lebih lengkap, silahkan membaca file referensi.bib yang disediakan juga di template ini.
Contoh kutipan:
\begin{itemize}
	\item Buku:~\cite{berg:08:compgeom} 
	\item Bab dalam buku:~\cite{kreveld:04:GIS}
	\item Artikel dari Jurnal:~\cite{buchin:13:median}
	\item Artikel dari prosiding seminar/konferensi:~\cite{kreveld:11:median}
	\item Skripsi/Thesis/Disertasi:~\cite{lionov:02:animasi}~\cite{wiratma:10:following}~\cite{wiratma:22:later}
	\item Technical/Scientific Report:~\cite{kreveld:07:watertight}
	\item RFC (Request For Comments):~\cite{RFC1654}
	\item Technical Documentation/Technical Manual:~\cite{Z.500}~\cite{unicode:16:stdv9}~\cite{google:16:and7}
	\item Paten:~\cite{webb:12:comm}
	\item Tidak dipublikasikan:~\cite{wiratma:09:median}~\cite{lionov:11:cpoly}
	\item Laman web:~\cite{erickson:03:cgmodel}  
	\item Lain-lain:~\cite{agung:12:tango}
\end{itemize}    
  
\subsection{Gambar}

Pada hampir semua editor, penempatan gambar di dalam dokumen \LaTeX{} tidak dapat dilakukan melalui proses {\it drag and drop}.
Perhatikan contoh pada file bab2.tex untuk melihat bagaimana cara menempatkan gambar.
Beberapa hal yang harus diperhatikan pada saat menempatkan gambar:
\begin{itemize}
	\item Setiap gambar {\bf harus} diacu di dalam teks (gunakan {\it field} {\sc label})
	\item {\it Field} {\sc caption} digunakan untuk teks pengantar pada gambar. Terdapat dua bagian yaitu yang ada di antara tanda $[$ dan $]$ dan yang ada di antara tanda $\{$ dan $\}$. Yang pertama akan muncul di Daftar Gambar, sedangkan yang kedua akan muncul di teks pengantar gambar. Untuk skripsi ini, samakan isi keduanya.
	\item Jenis file yang dapat digunakan sebagai gambar cukup banyak, tetapi yang paling populer adalah tipe {\sc png} (lihat Gambar~\ref{fig:ularpng}), tipe {\sc jpg} (Gambar~\ref{fig:ularjpg}) dan tipe {\sc pdf} (Gambar~\ref{fig:ularpdf})
	\item Besarnya gambar dapat diatur dengan {\it field} {\sc scale}.
	\item Penempatan gambar diatur menggunakan {\it placement specifier} (di antara tanda  $[$ dan $]$ setelah deklarasi gambar.
	Yang umum digunakan adalah {\bf H} untuk menempatkan gambar {\bf sesuai} penempatannya di file .tex atau  {\bf h} yang berarti "kira-kira" di sini. \\
	Jika tidak menggunakan {\it placement specifier}, \LaTeX{} akan menempatkan gambar secara otomatis untuk menghindari bagian kosong pada dokumen anda.
	Walaupun cara ini sangat mudah, hindarkan terjadinya penempatan dua gambar secara berurutan. 	
	\begin{itemize}
		\item Gambar~\ref{fig:ularpng} ditempatkan di bagian atas halaman, walaupun penempatannya dilakukan setelah penulisan 3 paragraf setelah penjelasan ini.
		\item Gambar~\ref{fig:ularjpg} dengan skala 0.5 ditempatkan di antara dua buah paragraf. Perhatikan penulisannya di dalam file bab2.tex!
		\item Gambar~\ref{fig:ularpdf} ditempatkan menggunakan {\it specifier} {\bf h}.
	\end{itemize}
\end{itemize}
 
%\dtext{17-18}
\begin{figure} 
	\centering  
	\includegraphics[scale=1]{ular-png}  
	\caption[Gambar {\it Serpentes} dalam format png]{Gambar {\it Serpentes} dalam format png} 
	\label{fig:ularpng} 
\end{figure} 

%\dtext{19-20}
\begin{figure}[H]
	\centering  
	\includegraphics[scale=0.5]{ular-jpg}  
	\caption[Ular kecil]{Ular kecil} 
	\label{fig:ularjpg} 
\end{figure} 
%\dtext{21-22}

\begin{figure}[ht] 
	\centering  
	\includegraphics[scale=1]{ular-pdf}  
	\caption[ {\it Serpentes} betina]{ {\it Serpentes} jantan} 
	\label{fig:ularpdf} 
\end{figure} 
 
\subsection{Kode Program}

Kode program dalam bahasa tertentu seringkali harus ditulis di dalam bab, bukan hanya dilampirkan di bagian Lampiran. 
Kode~\ref{kode:aneh} menampilkan penggunaan karakter-karakter yang umum digunakan dalam sebuah program yang ditulis dengan bahasa C.


\begin{lstlisting}[language=Java, caption=Kode untuk menampilkan karakter-karakter aneh, label=kode:aneh]
// This does not make algorithmic sense, 
// but it shows off significant programming characters.

#include<stdio.h>

void myFunction( int input, float* output ) {
	switch ( array[i] ) {
		case 1: // This is silly code
			if ( a >= 0 || b <= 3 && c != x )
				*output += 0.005 + 20050;
			char = 'g';
			b = 2^n + ~right_size - leftSize * MAX_SIZE;
			c = (--aaa + &daa) / (bbb++ - ccc % 2 );
			strcpy(a,"hello $@?"); 
	}
	count = ~mask | 0x00FF00AA;
}

// Fonts for Displaying Program Code in LATEX
// Adrian P. Robson, nepsweb.co.uk
// 8 October 2012
// http://nepsweb.co.uk/docs/progfonts.pdf

\end{lstlisting}

\subsection{Notasi}

Simbol-simbol (matematika) yang sering digunakan sepanjang penulisan skripsi, dapat dimasukkan ke dalam ``Daftar Notasi''. Daftar ini ada di halaman depan sebelum Bab~\ref{chap:intro}.
Cara memasukkan sebuah simbol ke dalam Daftar Notasi adalah menggunakan perintah \verb|\nomenclature|. Contoh:
\begin{center}
    \verb|\nomenclature[]{$A$}{luas kandang ular}|    
\end{center}
\nomenclature[]{$A$}{luas kandang ular}
\nomenclature[]{$n$}{banyaknya ular}
\nomenclature[]{$k$}{jumlah kepala per seekor ular\nomrefpage}
Argumen opsional digunakan untuk mengurutkan notasi. Silahkan lihat sendiri dokumentasi package \verb|nomencl|
\end{comment}
